---
title: Skills
description: "How to design, attach, and manage skills when building agents"
---

# Skills

When you first build an agent, it's tempting to pour everything into one big prompt: billing, support, verification, refunds, all crammed into a single "brain". It works for a demo, then quietly turns into something nobody wants to touch.

Skills are how you avoid that. A skill is a small, named capability — "Authenticate user", "Answer billing questions", "Create ticket" — with its own prompt, tools, and tags. Agents don't know everything; they pick up the skills they need as the conversation unfolds.

## Overview / Why it matters

In Wonderful, a skill is the unit of behavior you can **reason about, reuse, and swap** without rewriting the whole agent. Instead of asking "What does this 4‑page prompt do?", you ask:

- What skills does this agent have?  
- What does each one promise to handle?  
- When should the agent move from one skill to another?

Under the hood, a skill is a tenant-scoped object with a name, description, active flag, tools, and tags, and it can be attached to many agents. You rarely need to think about the struct names; what matters is that each skill is a focused playbook for a particular kind of work.

In Build, you use skills to:

- Break a large journey into focused capabilities (for example "Authenticate user", "Check balance", "Update address").  
- Reuse the same capability across multiple agents (support, sales, collections) without duplicating prompts.  
- Limit which tools and tags are active at any given moment, especially in multi-skill mode.  
- Make it obvious to product, CX, and engineering teams where a behavior lives.

<Info>
  A good test: if you can't explain a skill in one sentence – <em>"This skill handles X for Y kind of request."</em> – it's probably trying to do too much.
</Info>

## How skills behave at runtime

Think of a live call that wanders from **"Where's my order?"** to **"While I have you, can I update my card?"** to **"Actually my device is broken."** If you model that as one agent with one prompt, you either leave something out or you get a prompt nobody understands.

With skills:

1. You create a handful of specialist skills – for example `Delivery`, `Billing`, `Tech support`.  
2. You attach them to the agent.  
3. During the call, the agent starts in one skill and switches when the topic really changes.

In default mode, all attached skills are "loaded" from the start. In **multi‑skill** mode, the agent only has one skill "in its head" at a time. When the LLM decides it needs a different playbook, it calls an internal `switch_skill` tool; the runtime quietly rebuilds the prompt around the new skill, and the next sentence comes from that perspective.

Behind the scenes:

- Each skill owns its **tools** and **tags**. When the skill is active, those tools are callable and those tags can fire.  
- The agent configuration decides whether it runs with all skills loaded or in multi‑skill mode.  
- An inactive or disabled skill is effectively invisible: its tools and tags are out of play.

You can think of skills as **modular reasoning blocks**: the agent stays simple, while the catalogue of skills grows around it.

## How skills connect to agents and tools (flow chart)

Conceptually, skills sit between **agents** and **tools**:

```text
User request
  ↓
Agent (instructions, governance, channels)
  ↓ decides which capability is needed
Skill A / Skill B / Skill C
  ↓ owns
Tools (API, RAG, programmable, mock)
  ↓ call
Your systems (CRM, billing, ticketing, databases)
```

At the data-model level:

```text
Agent
  ↕ many-to-many via agents_skills
Skill
  ↘ owns many
    Tools
      ↔ integrate with external systems
  ↘ associated with many
    Tags
```

## Key ideas at a glance

- **Skill model**  
  - `Name`, `DisplayName`, `Description`: identify the skill and explain what it does.  
  - `Active`: whether the skill is currently enabled.  
  - `Tools`: tools owned by the skill, defining deterministic actions and integrations.  
  - `Tags`: tags associated with the skill for analytics, routing, and QA.  
  - `Agents`: agents that use this skill via the `agents_skills` mapping.

- **Agent–skill mapping**  
  - Many-to-many relationship that attaches skills to agents.  
  - Determines which skills (and therefore which tools and tags) are available for a given agent.

- **Multi-skill mode**  
  - Agent-level setting (`IsMultiSkill`) that changes how skills are loaded and switched at runtime.

## Create & manage skills in Build

<Steps>
  <Step title="Plan your skill breakdown">
    Identify natural boundaries in your use case (for example authentication vs account management vs ticketing). Aim for skills that represent complete tasks or domains, not single fields or trivial steps.
  </Step>

  <Step title="Create a new skill">
    1. Go to **Build > Skills** in the left sidebar
    2. Click **+ New Skill** in the top right
    3. Enter a **Name** (e.g., "Authenticate User") and **Description** that explains what the skill handles
    4. Click **Create**
  </Step>

  <Step title="Configure the skill">
    On the skill detail page:
    1. **Prompt tab**: Write the skill's instructions—what it should do and how it should behave
    2. **Tools tab**: Click **+ Add Tool** to attach API, RAG, or programmable tools the skill needs
    3. **Tags tab**: Add tags for analytics and routing (e.g., `auth_success`, `auth_failed`)
    4. Toggle **Active** to enable the skill
  </Step>

  <Step title="Attach skills to an agent">
    1. Go to **Build > Agents** and select your agent
    2. Click **Agent Studio** to open the Agent Studio screen
    3. In the Agent Studio, click **+ Add Skill** and select the skills you want to attach
    4. Confirm each attached skill is Active and correctly configured
  </Step>

  <Step title="Iterate with evals and monitoring">
    Run evals targeting specific skills to ensure their behavior is correct and stable, and use tags and metrics to observe how often each skill is used and how it performs.
  </Step>
</Steps>

## Design principles for your skill catalog

| Principle | Guidance |
|-----------|----------|
| Start from journeys | Map skills to user journeys ("reset password", "update card"), not internal team names |
| Name for outcomes | Prefer `Update Address` over `CRM Write`—names should be clear to product and CX teams |
| Keep skills cohesive | A skill should "handle X for Y situation". Split if unrelated behaviors; merge if it only wraps a single API call |
| Align prompts, tools, and tags | Each skill's prompt, tools, and tags should all describe the same domain |
| Reuse deliberately | Only share skills across agents when behavior and governance are truly identical |
| Version and test like code | Run evals before rolling out changes to skills that multiple agents depend on |

## Examples / Recipes

### Example 1 – Inbound support agent

For an inbound support agent that handles common account questions:

- **Skills**
  - <code>Authenticate User</code> — verifies identity using CRM or IdP tools; tagged with outcomes like <code>auth_success</code> / <code>auth_failed</code>.  
  - <code>Account Information</code> — reads balances, plans, and entitlements; tags conversations that mention renewals or upgrades.  
  - <code>Ticket Creation</code> — creates and updates tickets in your helpdesk, with tags for <code>ticket_created</code>, <code>ticket_updated</code>, and escalation reasons.

- **Tools per skill**
  - <code>Authenticate User</code>: API tools for customer lookup and verification.  
  - <code>Account Information</code>: API/RAG tools for account data and knowledge base articles.  
  - <code>Ticket Creation</code>: API tools for creating/updating tickets and adding internal notes.

In multi-skill mode, the agent might:

```text
User asks a question
  → Agent activates "Authenticate User"
  → If successful, switches to "Account Information"
  → If issue requires follow-up, switches to "Ticket Creation"
```

### Example 2 – Billing & collections agent

For a billing-focused agent:

- **Skills**
  - <code>Billing Overview</code> — answers questions about invoices, due dates, and payment methods.  
  - <code>Take Payment</code> — handles card payments or bank debits through PCI-compliant tools.  
  - <code>Disputes & Adjustments</code> — captures disputes, applies credits (where allowed), and routes edge cases to humans.

- **Tools per skill**
  - Billing data APIs, payment processor APIs, dispute-management tools.  
  - Deterministic tags like <code>payment_completed</code>, <code>high_risk_dispute</code>, <code>promise_to_pay</code> to drive dashboards and governance.

Here, separating <code>Take Payment</code> and <code>Disputes & Adjustments</code> helps you attach stricter governance and evals to those higher-risk paths.

### Example 3 – Internal operations assistant

For an internal assistant used by employees:

- **Skills**
  - <code>IT Help</code> — password resets, VPN access, device issues.  
  - <code>HR & Policies</code> — answers policy questions using RAG over your handbook.  
  - <code>Approvals & Requests</code> — opens internal requests and routes for approval.

- **Patterns**
  - Use skills to separate **read-only** flows (HR & Policies) from **state-changing** flows (Approvals & Requests).  
  - Attach stricter tools and tags to write paths, and design evals that focus on correct routing and compliance.

## Go deeper on skills

<CardGroup cols={3}>
  <Card title="Skill concepts" href="/understanding-the-platform/skills/what-skills-are">
    Learn how the <code>Skill</code> model works and how skills relate to agents and tools in the core platform.
  </Card>

  <Card title="Dynamic loading" href="/understanding-the-platform/skills/dynamic-loading">
    See how multi-skill mode works and how agents switch between skills at runtime.
  </Card>

  <Card title="Skill prompts &amp; tools" href="/understanding-the-platform/skills/skill-prompts-tools">
    Design prompts and tool groupings that keep each skill focused and reusable.
  </Card>
</CardGroup>

## FAQ's

<AccordionGroup>
  <Accordion title="How many skills should an agent have?">
    Start with a small number of well-defined skills. If a skill grows too large or handles too many domains, consider splitting it.
  </Accordion>

  <Accordion title="Can a skill be shared across agents?">
    Yes. Skills are designed to be reusable via the many-to-many relationship with agents.
  </Accordion>

  <Accordion title="What happens if I disable a skill on a live agent?">
    The skill's tools and tags will no longer be available for that agent. Test in non-production environments before disabling skills that handle critical workflows.
  </Accordion>
</AccordionGroup>
