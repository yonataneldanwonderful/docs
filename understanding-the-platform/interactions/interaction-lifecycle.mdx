---
title: "Interaction Lifecycle"
description: "How interactions progress from start to finish"
---

# Interaction Lifecycle

Interactions follow a lifecycle from initiation to completion, backed by the `Communication` model and enhancement pipeline. Understanding this flow helps when you design timeouts, escalation rules, and monitoring.

## Overview

An interaction starts when a customer and agent first connect on a channel, continues through a series of turns, tools, and events, and ends when the task is resolved or the conversation is terminated. The lifecycle is encoded in `Communication` fields like `Status`, `StartTime`, `EndTime`, `Duration`, `TokensUsage`, `Sentiment`, `Summary`, `Rating`, `CallTags`, and `Metadata`.

Services in the controller, runner, and processor coordinate to create, update, and enhance communications as the interaction moves through each stage.

## How It Works

### 1. Initiation

The interaction begins when:

- **Inbound** — The customer contacts the agent (voice, chat, email, WhatsApp, embed).  
- **Outbound** — The agent or system initiates contact with the customer.

At initiation:

- A `Communication` is created with `Type`, `Direction`, `AgentId`, `Status`, `StartTime`, and channel-specific identifiers (for example `FromNumber`, `ToNumber`, `Sid`).  
- The agent configuration (skills, tools, channel settings, prompts) is loaded.  
- Skills are registered (multi-skill) or pre-loaded (default mode).  
- Channel-specific initial messages are sent based on the agent and channel configuration.  
- Session tracking and tokens usage accounting begin.

### 2. Active Conversation

During the active phase:

- Agent and user exchange messages; transcripts and transcriptions are recorded for each turn.  
- Skills load dynamically as needed (multi-skill) or are available from the start (default mode).  
- Tools execute to perform actions according to their triggers (for example `on_user_transcription`, `on_agent_transcription`, `on_tool_call`).  
- Events are emitted and used to apply deterministic tags and call tags.  
- Timeouts and idle checks run based on the agent’s timeout and idle configuration.  
- Status remains `active` while the conversation is ongoing.

Special lifecycle hooks:

- **Before first message** — Tools with `on_before_first_message` run.  
- **After first message** — Tools with `on_after_first_message` run.  
- **User interruptions** — Tools with `on_user_interruption` run.  
- **User finished hearing** — Tools with `on_user_finished_hearing` run.

### 3. Resolution

Resolution is reached when:

- The user’s request is fulfilled and the agent completes the task.  
- The interaction is escalated to a human (for example via transfer or forwarding).  
- The user hangs up or closes the session.  
- A timeout or error occurs (idle timeout, hang-up after silence, maximum duration).  

At this point:

- The `EndedBy` metadata is set (customer, agent, or system).  
- Forwarding/transfer metadata is recorded when applicable.  
- The communication `Status` is moved toward a terminal state (for example `completed`, `failed`, `escalated`).  
- `EndTime` and `Duration` are set.

### 4. Completion & Enhancement

After the active part ends:

- **End-of-interaction tools** — Tools with `on_end` triggers run.  
- **Enhancement pipeline** runs asynchronously:  
  - Transcript clarification or normalization (if enabled).  
  - LLM tags applied based on the full conversation.  
  - Sentiment analysis and rating computation.  
  - Automated issue detection and call tag application.  
  - Summary generation (brief and detailed).  
  - Recording processing and storage (including masked audio and MP3 keys).  
  - Metric calculation and dashboard updates.

The communication ends in a terminal state with tags, call tags, rating, and summaries finalized.

## Components

- **Communication model** — Holds lifecycle core fields (`Status`, `StartTime`, `EndTime`, `Duration`, `TokensUsage`, `Sentiment`, `Summary`, `CallTags`, `Rating`, `Metadata`).  
- **Direction and participants** — `Direction`, `FromNumber`, `ToNumber`, and helpers like `GetCustomerNumber`/`GetAgentNumber`.  
- **Enhancement pipeline** — Processes transcripts, sentiment, tags, summaries, ratings, and call tags.  
- **Timeouts and time windows** — Governed by agent configuration and used to transition interactions out of `active` when idle or long-running.

## Usage

- **Design lifecycles** explicitly when building agents: decide how long interactions may run, when to escalate, and what happens on timeouts.  
- **Instrument interactions** with tags and call tags to make lifecycle transitions visible in monitoring and dashboards.  
- **Use enhancement outputs** (summaries, ratings, sentiment) to power QA workflows and issue detection.  
- **Analyze states and transitions** (for example `active → escalated → completed`) to improve routing and agent behavior.

## FAQ's

- **What happens if enhancement fails?**  
  The interaction remains completed, but enhancement-derived fields (tags, summaries, sentiment, ratings) may be missing or partial; failures are logged and can be alerted on via metrics.

- **Are interactions always tied to a recording?**  
  No. Voice interactions usually have recordings (with processed and masked variants), but chat and some email interactions will not.

- **Can an interaction be resumed after completion?**  
  New interactions are typically created for follow-ups; existing communications remain immutable records for analytics and compliance.

## Related

- [What Interactions Are](/understanding-the-platform/interactions/what-interactions-are)
- [Events, Tags, Metrics](/understanding-the-platform/interactions/events-tags-metrics)
- [What Agents Are](/understanding-the-platform/agents/what-agents-are)
- [LLM Tags](/understanding-the-platform/tags/llm-tags)
- [Deterministic Tags](/understanding-the-platform/tags/deterministic-tags)
